# Leveraging HPX on the Raspberry Pi Platform
This summer, with support from the National Science Foundation and LSU's Center for Computation and Technology, I sought to leverage HPX on a Raspberry Pi cluster, the objective being to show that the C++ library and run-time system ports to even the simplest of computer architectures. This blog post will describe in detail the roundabout way I managed to build HPX for the Pi platform, which could definitely use optimization but may still prove helpful for replicating the process.

I began by installing Raspbian-Jessie on a Raspberry Pi 3 Model B using the NOOBs package, which is available [here](https://www.raspberrypi.org/downloads/). With the OS set up, I began working to satisfy HPX's dependencies on the Pi. First, I installed jemalloc-dev using the built-in package manager. Unfortunately, the boost and hwloc packages available from the package manager were not updated enough to meet the requirements of HPX, so I downloaded and installed the unix versions of [Boost-1.64.0](http://www.boost.org/users/history/version_1_64_0.html) and [hwloc-1.11.7](https://www.open-mpi.org/software/hwloc/v1.11/), only specifying in the build options that they be installed in the root file system of the Pi. Lastly, I also installed cmake and ia32-libs with the Raspbian package manager. With all dependencies now satisfied on the Pi, I attempted to directly compile HPX many times without success. Abandoning that method, I transferred the root file sytem of the Pi to my desktop in order to cross-compile HPX.

Now working on my desktop, I downloaded [toolchain files](https://github.com/raspberrypi/tools) designed to cross-compile applications for the Raspberry Pi. There are excellent [instructions on Stack Overflow](https://stackoverflow.com/questions/19162072/installing-raspberry-pi-cross-compiler/19269715#19269715?newreg=05dd30d7184d4c518e31a1d2789962b8) for utilizing these toolchain files, which I followed to the letter, excepting the compilers they use in their example. In order for the g++ and gcc compilers to be updated sufficiently for HPX, I used those located in `toolchain_install_path/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin` instead of those in `toolchain_install_path/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin`. Finally, I managed to cross-compile HPX by messing with the cmake flags in my [build script](https://gist.github.com/JesseGoncalves/590fdc71456a7b78be88e020dcc03ccd#file-build_hpx_raspberry_pi_3-sh) and slightly changing the [toolchain file](https://gist.github.com/JesseGoncalves/590fdc71456a7b78be88e020dcc03ccd#file-pi-cmake). The cmake flags in the build script reference the Boost, hwloc, and jemalloc installations in the root file system of the Raspberry Pi as well as linking to the compilation toolchain. A hiccup I ran into with cross-compilation was that HPX had to be built in the same absolute location on my desktop as it would then be transferred to on the Pi. However, after building HPX in the root file system of my desktop and transferring the build directory to the same location on the Pi, I was able to run HPX applications and even show excellent parallel and distributed scaling!

If I attempted to build HPX for the Pi platform again, I would change many of the steps I followed. Firstly, I would start with a Raspbian image with the minimum requirements necessary for HPX and its dependencies to run. Secondly, I would not directly compile the entire Boost library on the Pi, as that required a lot of computation time. Instead, I would either use the package manager to get only the Boost libraries required by HPX or else cross-compile Boost on my desktop. Thirdly, I would look into building my own cross-compilation toolchain, as the highest version of gcc supported by the one I used was 4.9.3 and because of the valuable opportunity it would present to better understand the process of cross-compilation.


